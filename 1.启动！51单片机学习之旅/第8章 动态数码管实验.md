# 第八章 动态数码管实验

## 1. 数码管介绍

    上一章我们主要分析了一位数码管的内部结构及其控制原理（本质就是控制LED)。下面我们再来介绍多位数码管及其动态显示原理

### 1.1 多位数码管简介

    多位数码有两条重要的线，把公共端叫做”位选线“，连接在一起的段线叫做”段选线“，有了这两个线后，我们通过单片机及外部驱动电路就可以任意的数码管显示任意的数字了。

    当多位一体时，它们内部的公共端是独立的，而负责显示什么数字的段线是连在一起的，独立公共端可以控制多位一体中的任意一位点亮，而段线就用来控制显示什么数字。

    简单总结就是：位选控制亮不亮，至于显示什么看段选

    我们的开发板上面使用了2个四位一体的共阴极数码管，这样可以同时显示8个数字。

    更多内容可以参考：[复习单片机：动态数码管(1 数码管介绍+2 74HC245 和 74HC138 芯片介绍+3 硬件设计+4 软件设计+5 实验现象)-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/1091593)

### 1.2 数码管动态显示原理

    先来说说静态显示是怎么回事：静态显示应用于只显示一位数码管，或者同时显示相同内容。我们指定当多位数码管应用于某一系统时，它们的“ 位选” 是可独立控制的， 而“ 段选” 是连接在一起的， 我们可以通过位选信号控制哪几个数码管亮， 而在同一时刻， 位选选通的所有数码管上显示的数字始终都是一样的， 因为它们的段选是连接在一起的， 送入所有数码管的段选信号都是相同的， 所以它们显示的数字必定一样。

    动态显示就是减少段选线，分开位选线，利用位选线不同时选择通断，改变段选数据来实现的。

    比如在第一次选中第一位数码管时， 给段选数据 0，下一次位选中第二位数码管时显示 1。 为了在显示 1 的时候， 0 不会消失（ 当然实际上是消失了） ， 必须在人肉眼观察不到的时间里再次点亮第一次点亮的 0。而这时就需要记住， 人的肉眼正常情况下只能分辨变化超过 24ms 间隔的运动。也就是说， 在下一次点亮 0 这个数字的时间差不得大于 24ms。 这时就会发现，数码管点亮是在向右或者向左一位一位点亮， 形成了动态效果。 如果把间隔时间改长就能直接展现这一现象。

    更多内容可以参考：[C51单片机学习笔记(五)——数码管的静态显示和动态显示 | WD's blog (did321.github.io)](https://did321.github.io/2019/04/07/C51%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94-%E2%80%94%E2%80%94%E6%95%B0%E7%A0%81%E7%AE%A1%E7%9A%84%E9%9D%99%E6%80%81%E6%98%BE%E7%A4%BA%E5%92%8C%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA/)

## 2. 74HC245 和 74HC138 芯片介绍

    通过上一章学习我们知道，要想驱动数码管靠单片机IO口肯定是不行的，需要增加外部驱动，我们开发板上面使用的是74HC245芯片。同时考虑到51单片机的IO口有限，我们会使用一种IO口扩展芯片，我们开发板上面使用的是74HC138译码器芯片，只需单片机 3 个 IO 口就可以实现 8 个位选管脚的控制， 节省了芯片的 IO 资源。（74HC245用来驱动，74HC138用来扩展IO口）

### 2.1 74HC245芯片简介

![](https://img.picgo.net/2024/05/30/-2024-05-30-190151feda5ca659ec47ce.png)

    从管脚定义图我们可以看到怎么使用该芯片（如果能学习一些数电知识，看这个应该更容易）：给OE是能管脚低电平，DIR 管脚为高电平传输方向是 A->B 输出， DIR 为低电平传输方向是 B->A， 至于输出高电平还是输出低电平取决于输入端的状态， 如果输入为低电平， 输出即为低； 输入为高电平， 输出即为高。 如果 OE 使能管脚为高电平，不论 DIR 管脚是高还是低， 输出是高组态。（简单总结：DIR高电平A->B，DIR低电平B->A，OE为高电平输出高阻态）

    通常我们使用 74HC245 芯片用作驱动只会让其在一个方向输出， 即 DIR 管脚为高电平， 传输方向是 A->B。

    想要学习更多该芯片的知识可以参考：[74hc245中文资料详细（74hc245管脚功能_工作原理方法_电气特性及应用电路） - 电子发烧友网 (elecfans.com)](https://www.elecfans.com/yuanqijian/yinjiaotu/20180127624316.html)

### 2.2 74HC138芯片简介

![](https://img.picgo.net/2024/05/30/-2024-05-30-19063386516b7293bf6858.png)

    该芯片的工作原理也比较简单：给E1、 E2 使能管脚低电平， E3 管脚为高电平， 至于哪个管脚输出有效电平（ 低电平） ， 要看 A0， A1， A2 输入管脚的电平状态。 如果 A0， A1， A2 都为低电平， 则Y0 输出有效电平（ 低电平） ， 其他管脚均输出高电平。 如果 A0 为高电平， A1， A2 都为低电平， 则 Y1 输出有效电平（ 低电平） ， 其他管脚均输出高电平。如果 E1、 E2 使能管脚任意一个为高电平或者 E3 为低电平， 不论输入是什么， 输出都为高电平。

    更多内容参考：[74HC138译码器的原理和使用-CSDN博客](https://blog.csdn.net/diksan/article/details/122706792)

## 3. 硬件设计

我们需要用到：

- 动态数码管模块

- 74HC138

- 74HC245

![](https://img.picgo.net/2024/05/30/-2024-05-30-1918013c8b39c6fa4c2d43.png)

![](https://img.picgo.net/2024/05/30/-2024-05-30-1919089d2e55cbc8864971.png)

    可以看到动态数码管电路独立，段选端连接到 J6 端子上， 位选端连接到 J1 端子上。段选端通过 74HC245 芯片驱动这两个共阴数码管的 a-dp 段。

    欲控制动态数码管，需要将单片机管脚通过导线连接到J6段子和J1段子上，还有不要忘记了J9段子即74HC138也要与单片机连接，在下面的软件设计中，我们使用P2_2、P2_3、P2_4，所以使用 P0口控制数码管段选， 使用 P2.2、 P2.3、 P2.4 管脚控制 74HC138 译码器输入从而控制数码管位选。

## 4. 软件设计

    本章我们要实现的功能是：是数码管从左到右显示0-7

```c
#include <REGX52.H>

// 定义数码管段码口
#define SMG P0 

// 定义数码管位选信号控制脚
sbit LSA = P2^2;
sbit LSB = P2^3;
sbit LSC = P2^4;

// 共阴极数码管显示 0~F 的段码数据
unsigned char gsmg_code[16] = {
    0x3f,  // 0
    0x06,  // 1
    0x5b,  // 2
    0x4f,  // 3
    0x66,  // 4
    0x6d,  // 5
    0x7d,  // 6
    0x07,  // 7
    0x7f,  // 8
    0x6f,  // 9
    0x77,  // A
    0x7c,  // B
    0x39,  // C
    0x5e,  // D
    0x79,  // E
    0x71   // F
};

// 延时函数，延时十微秒
void delay_us(unsigned int ten_us) 
{
    while(ten_us--);
} 

// 数码管显示函数
void smg_display() 
{
    unsigned int i = 0;
    for(i = 0; i < 8; i++) 
    {    
        // 设置位选信号
        switch(7 - i) 
        {
            case 0: 
                LSC = 1; LSB = 1; LSA = 1;
                break;
            case 1: 
                LSC = 1; LSB = 1; LSA = 0;
                break;
            case 2:    
                LSC = 1; LSB = 0; LSA = 1;
                break;
            case 3: 
                LSC = 1; LSB = 0; LSA = 0;
                break;
            case 4: 
                LSC = 0; LSB = 1; LSA = 1;
                break;
            case 5: 
                LSC = 0; LSB = 1; LSA = 0;
                break;
            case 6: 
                LSC = 0; LSB = 0; LSA = 1;
                break;
            case 7:     
                LSC = 0; LSB = 0; LSA = 0;
                break;
        }

        // 传送段选数据并延时
        SMG = gsmg_code[i]; 
        delay_us(100); 
        // 消隐
        SMG = 0x00; 
    }
}

// 主函数
void main() 
{
    while(1) 
    {
        smg_display(); // 循环显示数码管
    }
}
```

下面我们来解释这个代码：

- 首先是头文件 不必多说，后面我们再宏定义了P0端口为SMG-此为方便理解，我们控制SMG就是控制P0端口

- 再定义了三个我们需要的管脚，再定义了共阴数码管的段码，这个已经出现多次，不必解释

- 写延时函数

- 重点是数码管显示函数，首先我们先生成一个循环（0-8）共8位代表了8位数码管，之后我们再在这个显示函数里嵌套switch循环

- switch循环用来设置位选信号（控制某位数码管亮灭与否）比如：第0位（即第1个数码管）switch（7）执行case 7语句（第1位数码管亮），以此类推

- 接着我们需要用SMG存储段选数据（即显示什么数字）

- 用延时函数来保持稳定

- 再使SMG为低电平，达成消隐的效果-去除数字残留-保证数字清晰

- 我们再在主函数里写一个循环显示数码管，如此大功告成

## 5. 小结

    这一章难度还算可以吧。相比上一章多了位选段选、消隐的概念。为什么要消隐可以看看这个：[请问数码管消隐是什么意思？_百度知道 (baidu.com)](https://zhidao.baidu.com/question/419522806.html)简单来说就是在循环点亮数码管的时候，其他数码管可能会突然亮一下，这个时候我们就需要解决这种情况-给端口低电平。

    位选段选我们应该很熟悉了-位选控制亮灭与否（switch循环控制）-段选控制显示什么数字（段码数组控制）

---

2024.6.25 第一次修订

2024.8.19 第二次修订，后期不再维护
